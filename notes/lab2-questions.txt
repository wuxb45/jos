==1==
Assuming that the following JOS kernel code is correct, what type should
variable x have, uintptr_t or physaddr_t?
  mystery_t x;
  char* value = return_a_pointer();
  *value = 10;
  x = (mystery_t) value;

type of x is 'uintput_t'.

==2==
What entries (rows) in the page directory have been filled in at this point?
What addresses do they map and where do they point? In other words, fill out
this table as much as possible:

Entry || Base VA    || Points to (logically):
1023  || 0xffc00000 ||\
1022  || 0xff800000 || | Top 256MB of phys memory
 ~~   ||  ~~        || |
1008  || 0xf0000000 ||/
1007  || 0xefc00000 || Empty: KSTACKTOP ~ KERNBASE
1006  || 0xef800000 || Invalid,kstack: ULIM ~ KSTACKTOP
1005  || 0xef400000 || RO PT: UVPT ~ ULIM
1004  || 0xef000000 || RO PAGES: UPAGES ~ UVPT
1003  || 0xeec00000 || RO ENVS: UTOP ~ UPAGES

00x00000000[see next question]

==3==
(From Lecture 3) We have placed the kernel and user environment in the same
address space. Why will user programs not be able to read or write the
kernel's memory? What specific mechanisms protect the kernel memory?

PTE_U is not set in the PTE entry so in user level an access to kernel memory
will cause a exception.

==4==
What is the maximum amount of physical memory that this operating system can
support? Why?

It would be 4GB in total, a virtual-physical translation
supports mapping an virtual address to a 32-bit physical address space,
thus a 4GB memory region is supported.

==5==
How much space overhead is there for managing memory, if we actually had the
maximum amount of physical memory? How is this overhead broken down?

The space comprises with two parts:
the space used by 'struct Page * pages', and the space used by PDEs & PTEs.
one struct Page takes 6 bytes, there would be 2^20 pages in the system with
4GB of memory, the total memory overhead would be 6MB.
PDEs statically takes 1024 * 4 bytes, that is 4KB.
each allocated PD contains 1024 * 4 bytes. in current system, there are 21 PDs
in page-table, comsuming 88KB of memory on page-tables.
(6MB + 88KB)

==6==
Revisit the page table setup in kern/entry.S and kern/entrypgdir.c.
Immediately after we turn on paging, EIP is still a low number
(a little over 1MB). At what point do we transition to running at an EIP above
KERNBASE? What makes it possible for us to continue executing at a low EIP
between when we enable paging and when we begin running at an EIP above
KERNBASE? Why is this transition necessary?

the low va (from 0 to 0x3ff000) are also mapped to paddr 0 to 0x3ff000.
0~+4MB    -> 0+4MB
252MB+4MB -> 0+4MB
running in either region is OK,
but the low va is not writeable (at least in the settings).

necessity: no single instruction to (enable paging + jump to new address).
